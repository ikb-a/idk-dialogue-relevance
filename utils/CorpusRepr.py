from os import linesep
import json

class Dialogue:
    """
    Representation of a single dialogue interaction.

    Class attributes:
    context - List of strings. If the data is in turns then each element is the next speaker (e.g. even indices are
                speaker A, and odd indices are speaker B)
    in_turns - Whether or not self.context is in turns.
    response - The ground truth response
    distractors - List of non-responses (typically selected randomly from corpus, or generated by machine)
    """

    def __init__(self, context, response, distractors, in_turns):
        """
        Initialize a Dialogue object

        :param context: List of strings. If the data is in turns then each element is the next speaker (e.g. even
                        indices are speaker A, and odd indices are speaker B)
        :param response: The ground truth response
        :param distractors: List of non-responses (typically selected randomly from corpus, or generated by machine)
        :param in_turns: Whether or not self.context is in turns. If not, context is a single element (the dialogue
                        context)
        """
        self.context = context
        self.response = response
        self.distractors = distractors
        self.in_turns = in_turns

    def get_context(self):
        """Get context as a single string, space separates dialogue turns."""
        return " ".join(self.context)

    def __repr__(self):
        return "Dialogue Object: in_turns: " + str(self.in_turns) + "# of distractors: " + \
               str(len(self.distractors)) + linesep + self.get_context() + linesep + self.response

    def __eq__(self, other):
        if not isinstance(other, Dialogue):
            return NotImplemented

        return self.context == other.context and self.response == other.response and \
               self.distractors == other.distractors and self.in_turns == other.in_turns

class AnnotatedDialogue(Dialogue):
    """
    Extends Dialogue to also contain a numeric annotation from 1 or more humans for each possible response.
    """
    def __init__(self, context, response, distractors, in_turns, resp_annot, distr_annots):
        """
        Initialize a Dialogue object

        :param context: List of strings. If the data is in turns then each element is the next speaker (e.g. even
                        indices are speaker A, and odd indices are speaker B)
        :param response: The ground truth response
        :param distractors: List of non-responses (typically selected randomly from corpus, or generated by machine)
        :param in_turns: Whether or not self.context is in turns. If not, context is a single element (the dialogue
                        context)
        :param resp_annot: List of annotation for each reviewer
        :param distr_annots: List of lists of annotations for each reviewer, list must be ordered such that order of
                            sublists matches order of corresponding distractors
        """
        self.resp_annot = resp_annot
        self.distr_annots = distr_annots
        assert(len(distr_annots) == len(distractors))
        Dialogue.__init__(self, context, response, distractors, in_turns)

    def __eq__(self, other):
        raise NotImplementedError

class Corpus:
    """
    Representation of a dialogue corpus.

    Class attributes:
    name - Name of the corpus
    dialogues - List of Dialogue objects from this corpus
    distractor_names - Names of the distractors if available
    """
    def __init__(self, name, distractor_names=None):
        """
        Initializes the corpus. Dialogues are stored in self.dialgues as a list of Dialogue objects.
        :param name: Name of the corpus
        :param distractor_names: If applicable, the names of the distractors in order (purely for convenience)
        """
        self.dialogues = []
        if distractor_names is None:
            self.distractor_names = []
        else:
            self.distractor_names=distractor_names
        self.name = name

    def __repr__(self):
        return "Corpus: Name: " + self.name + " # of Dialogues: " + str(len(self.dialogues))

    def __eq__(self, other):
        if not isinstance(other, Corpus):
            return NotImplemented
        else:
            return self.name == other.name and self.dialogues == other.dialogues

def save_corpus(corpus, path):
    """
    Saves the Corpus object corpus as a .json file at path. It can be read back using load_corpus.

    ***NOTE: This function modifies corpus in place to save memory! If the original is still needed, load from .json***

    :param corpus: Corpus object
    :param path: Path to which to save the .json representation of corpus
    """
    corpus.dialogues = list(map(lambda x: x.__dict__,corpus.dialogues))
    corpus = corpus.__dict__

    with open(path, 'w') as file:
        #json.dump(corpus, file)
        file.write(json.dumps(corpus, indent=4))


def load_corpus(path, load_annot=False) -> Corpus:
    with open(path, 'r') as file:
        corpus = json.load(file)

    def CreateDialogue(x):
        if load_annot and 'resp_annot' in x:
            if 'distr_annot' in x:
                return AnnotatedDialogue(x['context'], x['response'], x['distractors'], x['in_turns'],
                                         x['resp_annot'], x['distr_annot'])
            else:
                # Incompatibility arose at some point in time, somehow HUMOD dataset uses 'distr_annot' whereas
                # Quality corpuses use 'distr_annots' (note the extra 's')
                return AnnotatedDialogue(x['context'], x['response'], x['distractors'], x['in_turns'],
                                         x['resp_annot'], x['distr_annots'])
        else:
            return Dialogue(x['context'], x['response'], x['distractors'], x['in_turns'])

    corpus['dialogues'] = list(map(CreateDialogue, corpus['dialogues']))
    result = Corpus(corpus['name'])
    result.dialogues = corpus['dialogues']
    result.distractor_names = corpus['distractor_names']
    result.name = corpus['name']
    return result